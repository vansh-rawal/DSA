// Q4 INFIX TO POSTFIX

#include <iostream>
#include <string.h>
using namespace std;

#define size 10
char stack[size];
int top = -1;

void push(char c){
    if(top==size - 1){
        cout<<"Overflow"<<endl;
    }
    else{
        top++;
        stack[top]=c;
    } 
}
char pop(){
    if(top==-1){
        return '\0';
    }
    else{
        char s=stack[top];
        top--;
        return s;
    }
}
char peek() {
    if(top == -1){
        return '\0';
    }
    return stack[top];
}
int Precedence(char op) {
    if(op=='^') return 3;
    if(op=='*' || op=='/') return 2;
    if(op=='+' || op=='-') return 1;
    return 0;
}
bool isOperator(char c){
    return (c=='+' || c=='-' || c=='*' || c=='/' || c=='^');
}

int main() {
    char infix[size], postfix[size];
    cout<<"Enter infix expression:";
    cin>>infix;

    int k=0;
    for(int i=0;i<strlen(infix);i++){
        char ch=infix[i];
        if((ch>='a' && ch<='z') || (ch>='A' && ch<='Z') || (ch>='0' && ch<='9')){
            postfix[k]=ch;
            k++;
        }
        else if(ch=='(') {
            push(ch);
        }
        else if(ch==')'){
            while(top!=-1 && peek()!='(') {
                postfix[k]=pop();
                k++;
            }
            pop();
        }
        else if(isOperator(ch)){
            while(top!=-1 && Precedence(peek())>=Precedence(ch)) {
                postfix[k] = pop();
                k++;
            }
            push(ch);
        }
    }
    while(top!=-1){
        postfix[k]=pop();
        k++;
    }
    postfix[k]='\0';
    cout<<"Postfix expression:"<<postfix<<endl;

    return 0;
}
